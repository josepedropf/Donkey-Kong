import pygame
import math

pygame.init()

screen = pygame.display.set_mode((800, 800))

x = 180
y = 702
xb = 240
yb = 159
barrels = [[xb, yb, 7]]
sprites = [
    "mario.png",
    "marion.png",
    "marioj.png",
    "mariorev.png",
    "marionrev.png",
    "mariojrev.png",
    "mariob.png",
    "mariost.png",
    "mariostrev.png",
    "mariostend.png",
    "mariostendrev.png",
    "dk.png",
    "dkb.png",
    "phelp.png",
    "plove.png",
    "marioll.png",
    "marioh.png"
]

sprt = sprites[1]
dk_sprt = sprites[11]
p_sprt = sprites[13]
last_sprt = sprites[0]
cplat = 0
plat_max = 0
jumptime = 0
climbing = False
lost_life = False
ll_anim = False
win = False
gameover = False
time_last_barrel = pygame.time.get_ticks()
anim_time = pygame.time.get_ticks()
font_g = pygame.font.SysFont("comicsans", 30, True)
score = 0
rscore = 0
lives = 3

R = 12
G = 5
LB = math.sqrt(2 * (R ** 2))
SIZE = (30, 45)
A_BARREL = (math.pi) * (R ** 2)
VM = 4
VB = 3
DK_SIZE = (150, 110)
DK_POS = [240 - DK_SIZE[0], 159 - DK_SIZE[1]]
P_SIZE = (80, 60)
P_POS = (320, 69 - P_SIZE[1])
SCORE_POS = (600, 10)
LIVES_POS = (600, 40)


stairs = [
    (0, ((640, 649), (680, 651), (680, 749), (640, 746))),
    (1, ((120, 531), (160, 529), (160, 626), (120, 626))),
    (1, ((340, 522), (380, 520), (380, 637), (340, 637))),
    (2, ((400, 401), (440, 403), (440, 519), (400, 519))),
    (2, ((640, 412), (680, 414), (680, 509), (640, 509))),
    (3, ((120, 294), (160, 291), (160, 389), (120, 389))),
    (3, ((220, 290), (260, 287), (260, 394), (220, 394))),
    (4, ((640, 174), (680, 176), (680, 271), (640, 271))),
    (5, ((440, 69), (480, 69), (480, 167), (440, 167)))
]

stairs_broken = [
    (0, ((280, 632), (320, 634), (320, 760), (280, 760))),
    (2, ((240, 393), (280, 395), (280, 525), (240, 525))),
    (3, ((580, 274), (620, 272), (620, 411), (580, 411))),
    (4, ((320, 160), (360, 161), (360, 284), (320, 284))),
    (5, ((240, 99), (280, 99), (280, 159), (240, 159))),
    (5, ((280, 99), (320, 99), (320, 159), (280, 159)))
]

platforms = [
    ((800, 740), (800, 770), (0, 800), (0, 770)),
    ((26, 619), (720, 653), (720, 683), (26, 649)),
    ((774, 504), (774, 534), (80, 562), (80, 532)),
    ((26, 382), (720, 416), (720, 446), (26, 412)),
    ((774, 266), (774, 296), (80, 325), (80, 295)),
    ((320, 159), (720, 178), (720, 208), (320, 189)),
    ((320, 69), (480, 69), (480, 99), (320, 99)),
    ((26, 159), (320, 159), (320, 189), (26, 189)),
    ((240, 99), (320, 99), (320, 129), (240, 129))
]

mpos = pygame.mouse.get_pos()
click = pygame.mouse.get_pressed()

font_menu = pygame.font.SysFont("comicsans", 50, True)
box_size = (100, 40)
xbox = 400 - int(box_size[0] / 2)
POS_CL = (xbox, 100)
POS_RE = (xbox, 200)
POS_CO = (xbox, 300)
POS_QU = (xbox, 400)
positions = [POS_CL, POS_RE, POS_CO, POS_QU]
boxes = [pygame.Rect(post, box_size) for post in positions]


def draw_menu(alist):
    cl_text = font_menu.render("Classic", 1, pygame.Color(alist[0]))
    re_text = font_menu.render("Remix", 1, pygame.Color(alist[1]))
    co_text = font_menu.render("Controls", 1, pygame.Color(alist[2]))
    qu_text = font_menu.render("Quit", 1, pygame.Color(alist[3]))
    texts = [cl_text, re_text, co_text, qu_text]
    screen.fill((0, 0, 0))
    for box in boxes:
        ind = boxes.index(box)
        pygame.draw.rect(screen, pygame.Color("black"), box)
        screen.blit(texts[ind], positions[ind])
    pygame.display.update()
    pygame.display.flip()
    

menu = True
running = True
classic = False
clock = pygame.time.Clock()

while running is True:
    dt = clock.tick(30)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    def mouse_over(pos):
        if mpos[0] in range(xbox, xbox + box_size[0]) and mpos[1] in range(pos[1], pos[1] + box_size[0]):
            return True

    if menu is True:
        colors = ["yellow", "yellow", "yellow", "yellow"]
        draw_menu(colors)
        for post in positions:
            ind = positions.index(post)
            if mouse_over(post) is True:
                colors[ind] = "blue"
            else:
                colors[ind] = "yellow"
        print(mouse_over(POS_CL))
        if mouse_over(POS_CL) and click[0] == 1:
            classic = True
            menu = False
    
    if classic is True:
        def draw_screen(stairs, stairs_broken, platforms):
            for s in stairs:
                pygame.draw.polygon(screen, pygame.Color('blue'), s[1])
            for sb in stairs_broken:
                pygame.draw.polygon(screen, pygame.Color('brown'), sb[1])
            for p in platforms:
                pygame.draw.polygon(screen, pygame.Color('red'), p)
    
        def draw_screen_charct(stairs, stairs_broken, platforms, Dk, Princess, text_score):
            draw_screen(stairs, stairs_broken, platforms)
            screen.blit(Princess, P_POS)
            screen.blit(Dk, DK_POS)
            screen.blit(text_score, SCORE_POS)
            
        Mario = pygame.transform.scale(pygame.image.load(sprt), SIZE)
        Mario_lostlife = pygame.transform.scale(pygame.image.load(sprites[15]), SIZE)
        Dk = pygame.transform.scale(pygame.image.load(dk_sprt), DK_SIZE)
        Princess = pygame.transform.scale(pygame.image.load(p_sprt), P_SIZE)
        last_sprt = sprt
        text_score = font_g.render("Score: " + str(score), 1, pygame.Color('white'))
        text_lives = font_g.render("Lives: " + str(lives), 1, pygame.Color('white'))
        pos = (x, y)
    
        def y_min(x, plat):
            p = list(platforms[plat])
            y1 = 800
            y2 = 800
            x1 = p[0][0]
            for a in range(len(p)):
                if p[a][0] != x1:
                    x2 = p[a][0]
            for i in p:
                if i[0] == x1:
                    if i[1] < y1:
                        y1 = i[1]
                if i[0] == x2:
                    if i[1] < y2:
                        y2 = i[1]
            n = (y2 - y1) / (x2 - x1)
            b = y1 - (n * x1)
            return (n * x + b)
        
        if lost_life:
            lives -= 1
            text_lives = font_g.render("Lives: " + str(lives), 1, pygame.Color('white'))
            barrels = []
            y = y_min(x, cplat) - SIZE[1]
            screen.fill((0, 0, 0))
            draw_screen_charct(stairs, stairs_broken, platforms, Dk, Princess, text_score)
            screen.blit(pygame.transform.scale(pygame.image.load(sprites[16]), SIZE), (x, y))
            pygame.display.update()
            pygame.display.flip()
            pygame.time.wait(1000)
            while y < 799:
                screen.fill((0, 0, 0))
                draw_screen_charct(stairs, stairs_broken, platforms, Dk, Princess, text_score)
                screen.blit(Mario_lostlife, (x, y))
                screen.blit(text_score, SCORE_POS)
                pygame.display.update()
                pygame.display.flip()
                y += 1
            x = 180
            y = 702
            cplat = 0
            sprt = sprites[1]
            screen.fill((0, 0, 0))
            screen.blit(text_lives, (400, 400))
            pygame.display.update()
            pygame.display.flip()
            pygame.time.wait(2000)
            lost_life = False
        
        if lives == 0:
            gameover = True
            
        if win:
            barrels = []
    
         
        def inst(x, y, plat, size):
            stairs_plat = []
            for s in stairs:
                if s[0] == plat:
                    stairs_plat.append(s[1])
            for ss in stairs_plat:
                if x + (size[0] / 2) in range(ss[0][0], ss[1][0]) and y <= y_min(x, cplat) - size[1]:
                    return True
            return False
        
        def inbst(x, y, plat, size):
            bstairs_plat = []
            for sb in stairs_broken:
                if sb[0] == plat:
                    bstairs_plat.append(sb[1])
            for ssb in bstairs_plat:
                if x + (size[0] / 2) in range(ssb[0][0], ssb[1][0]) and y <= y_min(x, cplat) - size[1]:
                    return True
            return False
        
        def inplat(x, plat, c):
            xmin = 800
            xmax = 0
            for atuple in platforms[plat]:
                if atuple[0] < xmin:
                    xmin = atuple[0]
                if atuple[0] > xmax:
                    xmax = atuple[0]
            return x in range(xmin - c, xmax)
          
        if inplat(x, cplat, SIZE[0]) is False and y == y_min(x, cplat) - SIZE[1]:
            cplat -= 1
            
        if not lost_life and not win:
            keys = pygame.key.get_pressed()
            
        if inst(x, y, cplat - 1, SIZE) is True and keys[pygame.K_DOWN]:
            cplat -= 1
            climbing = True
            
        if keys[pygame.K_q]:
            running = False
    
        if keys[pygame.K_SPACE]:
            if y == y_min(x, cplat) - SIZE[1]:
                jumptime = 10
           
        if keys[pygame.K_RIGHT]:
            if x < 760 and climbing is False and win is False:
                x += VM
        
        if keys[pygame.K_LEFT]:
            if cplat < 5:
                if x > 0 and climbing is False and win is False:
                    x -= VM
            else:
                if x > 320 and climbing is False and win is False:
                    x -= VM
                
        if jumptime != 0:
            y -= G
            jumptime -= 1
    
        if jumptime == 0 and climbing is False:
            y += G
            if y > y_min(x, cplat) - SIZE[1]:
                y = y_min(x, cplat) - SIZE[1]
                
        if y < y_min(x, cplat) - SIZE[1] and climbing is False:
            if keys[pygame.K_LEFT]:
                sprt = sprites[5]
            elif keys[pygame.K_RIGHT]:
                sprt = sprites[2]
            else:
                if last_sprt == sprites[0] or last_sprt == sprites[1]:
                    sprt = sprites[2]
                if last_sprt == sprites[3] or last_sprt == sprites[4]:
                    sprt = sprites[5]
    
        if y == y_min(x, cplat) - SIZE[1] and climbing is False:
            if keys[pygame.K_RIGHT] and not keys[pygame.K_LEFT]:
                if last_sprt != sprites[0] and last_sprt != sprites[1]:
                    sprt = sprites[1]
                if last_sprt == sprites[1]:
                    if pygame.time.get_ticks() - anim_time > 100:
                        sprt = sprites[0]
                if last_sprt == sprites[0]:
                    if pygame.time.get_ticks() - anim_time > 100:
                        sprt = sprites[1]
            elif keys[pygame.K_LEFT] and not keys[pygame.K_RIGHT]:
                if last_sprt != sprites[3] and last_sprt != sprites[4]:
                    sprt = sprites[4]
                if last_sprt == sprites[4]:
                    if pygame.time.get_ticks() - anim_time > 100:
                        sprt = sprites[3]
                if last_sprt == sprites[3]:
                    if pygame.time.get_ticks() - anim_time > 100:
                        sprt = sprites[4]
            else:
                if last_sprt == sprites[5]:
                    sprt = sprites[4]
                if last_sprt == sprites[2]:
                    sprt = sprites[1]
    
        if climbing is True:
            if y == y_min(x, cplat) - SIZE[1]:
                sprt = sprites[6]
            elif y - y_min(x, cplat + 1) > 10:
                if (keys[pygame.K_UP] and not keys[pygame.K_DOWN]) or (keys[pygame.K_DOWN] and not keys[pygame.K_UP]):
                    if last_sprt != sprites[7] and last_sprt != sprites[8]:
                        sprt = sprites[7]
                    if last_sprt == sprites[7]:
                        if pygame.time.get_ticks() - anim_time > 200:
                            sprt = sprites[8]
                    if last_sprt == sprites[8]:
                        if pygame.time.get_ticks() - anim_time > 200:
                            sprt = sprites[7]
            else:
                if (keys[pygame.K_UP] and not keys[pygame.K_DOWN]) or (keys[pygame.K_DOWN] and not keys[pygame.K_UP]):
                    if last_sprt != sprites[9] and last_sprt != sprites[10]:
                        sprt = sprites[9]
                    if last_sprt == sprites[9]:
                        if pygame.time.get_ticks() - anim_time > 200:
                            sprt = sprites[10]
                    if last_sprt == sprites[10]:
                        if pygame.time.get_ticks() - anim_time > 200:
                            sprt = sprites[9]
                    
        if last_sprt != sprt:
            anim_time = pygame.time.get_ticks()
               
        if jumptime == 0:
            y = min(y, y_min(x, cplat) - SIZE[1])
                
        if cplat > plat_max:
            plat_max = cplat
        if inst(x, y, cplat, SIZE) is True:
            if y == y_min(x, cplat) - SIZE[1] and keys[pygame.K_UP]:
                climbing = True
            if climbing is True:
                if keys[pygame.K_DOWN]:
                    y += 4
                if keys[pygame.K_UP]:
                    y -= 4
            if y < y_min(x, cplat + 1) - SIZE[1]:
                if cplat == plat_max:
                    score += 200
                    rscore += 200
                cplat += 1
                climbing = False
                sprt = sprites[6]
        
        if y == y_min(x, cplat) - SIZE[1] or inst(x, y, cplat, SIZE) is False:
            climbing = False
        
        if inst(x, y, cplat, SIZE) is True and climbing is False:
            if last_sprt == sprites[7] or last_sprt == sprites[8]:
                sprt = sprites[6]
        
        for barrel in barrels:
            if barrel[2] == 7 and barrel[0] == 321:
                barrel[2] -= 2
            
        for barrel in barrels:
            if inplat(barrel[0], barrel[2], R) is True:
                if barrel[1] + R < y_min(barrel[0], barrel[2]):
                    barrel[1] += G
                else:
                    if barrel[2] % 2 == 0:
                        barrel[0] -= VB
                    else:
                        barrel[0] += VB
            else:
                barrel[2] -= 1
            if barrel[2] == 0 and barrel[0] <= R:
                barrels.remove(barrel)
            if barrel[2] == cplat and climbing is False:
                if lost_life is False and x + (SIZE[0] / 2) in range(barrel[0] - 2, barrel[0] + 2) and y + (SIZE[1] / 2) < barrel[1]:
                    score += 100
                    rscore += 100
    
        if pygame.time.get_ticks() - time_last_barrel > 5000 and win is False:
            barrels.append([xb, yb, 7])
            time_last_barrel = pygame.time.get_ticks()
        if pygame.time.get_ticks() - time_last_barrel > 4800 or pygame.time.get_ticks() - time_last_barrel < 200:
            dk_sprt = sprites[12]
        else:
            dk_sprt = sprites[11]
    
        for barrel in barrels[1:]:
            if barrel[2] > cplat:
                if inst(barrel[0], barrel[1], barrel[2] - 1, (0, SIZE[1])) or inbst(barrel[0], barrel[1], barrel[2] - 1, (0, SIZE[1])):
                    barrel_x = [bb[0] for bb in barrels if bb[2] == barrel[2] - 1]
                    for bx in barrel_x:
                        if abs(barrel[0] - bx) > 250:
                            if abs(barrel[0] - x) <= 3:
                                barrel[2] -= 1
                            if barrel[0] > x and keys[pygame.K_RIGHT]:
                                barrel[2] -= 1
                            if barrel[0] < x and keys[pygame.K_LEFT]:
                                barrel[2] -= 1
    
        screen.fill((0, 0, 0))
        draw_screen(stairs, stairs_broken, platforms)
        for barrel in barrels:
            if lost_life is False:
                pygame.draw.circle(screen, pygame.Color('green'), barrel[:2], R)
    
        Mariobox = pygame.Rect(pos, SIZE)
        for barrel in barrels:
            box = pygame.Rect(barrel[0] - (LB / 2), barrel[1] - (LB / 2), LB, LB)
            if Mariobox.colliderect(box):
                lost_life = True
    
        if cplat == 6:
            win = True
        
        if win is True:
            p_sprt = sprites[14]
            screen.blit(pygame.transform.rotate(pygame.transform.scale(pygame.image.load(sprites[11]), DK_SIZE), 180), (DK_POS[0], 680))
            sprt = sprites[4]

        if lost_life is False:
            screen.blit(Mario, pos)
        
        if win is False:
            p_sprt = sprites[13]
            screen.blit(Dk, DK_POS)
            
        if rscore >= 3000:
            lives += 1
            rscore = 0
            
        screen.blit(Princess, P_POS)
        screen.blit(text_score, SCORE_POS)
        screen.blit(text_lives, LIVES_POS)
        pygame.display.update()
        pygame.display.flip()
    
del font_g
del font_menu
pygame.display.quit()
pygame.quit()

"""
# Mario == 60p (altura) * 40p (largura) | Barril == 30p |
# Plataforma_largura == 30p | Plataforma_comp == 80p | Mini_plat == 54p (-26p)
# d_curta_plat == 60p | d_longa_plat == 120p
# Oil na segunda plat | Mario na terceira

# Equações retas superiores das plataformas:
# Plat 0 == (-30/800) * x + 770 ((800, 740), (800, 770), (0, 800), (0, 770))
# Plat 1 == (17/347) * x + 618 ((26, 619), (720, 653), (720, 683), (26, 649))
# Plat 2 == (-14/347) * x + 535 ((774, 504), (774, 534), (80, 562), (80, 532))
# Plat 3 == (17/347) * x + 381 ((26, 382), (720, 416), (720, 446), (26, 412))
# Plat 4 == (-14/347) * x + 297 ((774, 266), (774, 296), (80, 325), (80, 295))
# Plat 5 inclinada == (19/400) * x + 144 ((320, 159), (720, 178), (720, 208), (320, 189))
# Plat 6 Princesa == 69 ((320, 69), (480, 69), (480, 99), (320, 99))
# Plat 7 plana == 159 ((26, 159), (320, 159), (320, 189), (26, 189))
# Plat 8 Barris == 99 ((240, 99), (320, 99), (320, 129), (240, 129))

#xi == 180
#yi == 703
"""
